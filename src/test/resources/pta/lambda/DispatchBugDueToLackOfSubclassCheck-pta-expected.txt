Points-to sets of all variables
[]:<DispatchBugDueToLackOfSubclassCheck$ClassWithInstanceMethod: void <init>()>/%this -> [[]:NewObj{<DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>[0@L14] new DispatchBugDueToLackOfSubclassCheck$ClassWithInstanceMethod}]
[]:<DispatchBugDueToLackOfSubclassCheck$ClassWithInstanceMethod: void foo()>/%this -> [[]:NewObj{<DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>[0@L14] new DispatchBugDueToLackOfSubclassCheck$ClassWithInstanceMethod}]
[]:<DispatchBugDueToLackOfSubclassCheck$ClassWithStaticMethod: void <init>()>/%this -> [[]:NewObj{<DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>[2@L15] new DispatchBugDueToLackOfSubclassCheck$ClassWithStaticMethod}]
[]:<DispatchBugDueToLackOfSubclassCheck: void consume(java.lang.Object,java.util.function.Consumer)>/r0 -> [[]:LambdaObj{alloc=<DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>[4@L16] $r2 = invokedynamic <java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)> "accept" <MethodType: java.util.function.Consumer ()>[MethodType: void (java.lang.Object),MethodHandle[REF_invokeVirtual]: <DispatchBugDueToLackOfSubclassCheck$ClassWithInstanceMethod: void foo()>,MethodType: void (DispatchBugDueToLackOfSubclassCheck$ClassWithInstanceMethod)](),type=java.util.function.Consumer in <DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>}]
[]:<DispatchBugDueToLackOfSubclassCheck: void consume(java.lang.Object,java.util.function.Consumer)>/r1 -> [[]:NewObj{<DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>[0@L14] new DispatchBugDueToLackOfSubclassCheck$ClassWithInstanceMethod}, []:NewObj{<DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>[2@L15] new DispatchBugDueToLackOfSubclassCheck$ClassWithStaticMethod}]
[]:<DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>/$r0 -> [[]:NewObj{<DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>[0@L14] new DispatchBugDueToLackOfSubclassCheck$ClassWithInstanceMethod}]
[]:<DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>/$r1 -> [[]:NewObj{<DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>[2@L15] new DispatchBugDueToLackOfSubclassCheck$ClassWithStaticMethod}]
[]:<DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>/$r2 -> [[]:LambdaObj{alloc=<DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>[4@L16] $r2 = invokedynamic <java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)> "accept" <MethodType: java.util.function.Consumer ()>[MethodType: void (java.lang.Object),MethodHandle[REF_invokeVirtual]: <DispatchBugDueToLackOfSubclassCheck$ClassWithInstanceMethod: void foo()>,MethodType: void (DispatchBugDueToLackOfSubclassCheck$ClassWithInstanceMethod)](),type=java.util.function.Consumer in <DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>}]
[]:<DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>/r3 -> [[]:EntryPointObj{alloc=<main-arguments>,type=java.lang.String[] in <DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>}]
[]:<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>/dynamicMethodType -> [[]:ConstantObj{java.lang.invoke.MethodType: MethodType: void (DispatchBugDueToLackOfSubclassCheck$ClassWithInstanceMethod)}]
[]:<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>/factoryType -> [[]:ConstantObj{java.lang.invoke.MethodType: MethodType: java.util.function.Consumer ()}]
[]:<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>/implementation -> [[]:ConstantObj{java.lang.invoke.MethodHandle: MethodHandle[REF_invokeVirtual]: <DispatchBugDueToLackOfSubclassCheck$ClassWithInstanceMethod: void foo()>}]
[]:<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>/interfaceMethodName -> [[]:ConstantObj{java.lang.String: "accept"}]
[]:<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>/interfaceMethodType -> [[]:ConstantObj{java.lang.invoke.MethodType: MethodType: void (java.lang.Object)}]
[]:<java.lang.invoke.LambdaMetafactory: java.lang.invoke.CallSite metafactory(java.lang.invoke.MethodHandles$Lookup,java.lang.String,java.lang.invoke.MethodType,java.lang.invoke.MethodType,java.lang.invoke.MethodHandle,java.lang.invoke.MethodType)>/r1 -> [[]:MethodHandlesLookupObj{alloc=DispatchBugDueToLackOfSubclassCheck,type=java.lang.invoke.MethodHandles$Lookup}]

Points-to sets of all static fields

Points-to sets of all instance fields

Points-to sets of all array indexes
[]:EntryPointObj{alloc=<main-arguments>,type=java.lang.String[] in <DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>}[*] -> [[]:EntryPointObj{alloc=<main-arguments-element>,type=java.lang.String in <DispatchBugDueToLackOfSubclassCheck: void main(java.lang.String[])>}]

